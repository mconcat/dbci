syntax = "proto3";

package dbci.operation;

option go_package = "github.com/mconcat/dbci/operation/types";

message Uint256 {
    bytes data = 1;
}

message Int256 {
    bytes data = 1;
}

message Dec256 {
    Uint256 significand = 1;
    uint32 exponent = 2;
}

message Asset {
    string denom = 1;
    optional Uint256 id = 2; // explicitly optional, NFT purpose
    Uint256 amount = 3;
}

// FromSingle :: State
message FromSingle {
    repeated bytes key = 1;
}

// FromEnumerable :: Stream<State>
message FromEnumerable {
    repeated bytes prefix = 1;
    bytes from = 2;
    bytes to = 3;
    bool ascending = 4;
}


// FunctionNumeric :: Numeric -> Numeric
message FunctionNumeric {
    enum Operator {
        UNKNOWN = 0;
        ADD = 1;
        SUB = 2;
        SUBFROM = 3;
        MUL = 4;
        DIV = 5;
        LT = 6;
        LTE = 7;
        GT = 8;
        GTE = 9;
        EQ = 10;
        NEQ = 11;
    }
    Operator operator = 1;
    // When the operands are nil, FunctionNumeric act as a n-ary operator on stream of tuple values
    oneof operand {
        uint64 uint64Operand = 2;
        int64 int64Operand = 3;
        Uint256 Uint256Operand = 4;
        Int256 Int256Operand = 5;
    }
}

message FunctionEffectful {
    enum FunctionType {
        UNKNOWN = 0;
        SELECT = 1;
        SET = 2;
        DELETE = 3;
    }
    FunctionType ty = 1;
}

// FunctionSet :: T -> T
// modifies the value with the computated 
// Usage: SelectField(field) >> FunctionNumeric(ADD, 3) >> FunctionSet()
// select field of the current item, add 3 to the field, and set
message FunctionSet {}

message FunctionDelete {}

// FunctionSelectField ::
// a, b proto.Message => a -> b
// This is equal with FieldDescriptor, I just couldnt found how to import it properly
message FunctionSelectField {
    int32 fieldNumber = 1;
    int32 fieldType = 2; // int8, consider switching to enum
}

message FunctionSequence {
    repeated Function fn = 1;
}

// FunctionHighorder takes a single unary function and lifts it to list level
// or processes the enumeration without a base function
// FunctionEnumerable can be used both on list element and enumeration stream
message FunctionEnumerable {
    enum FunctionType {
        UNKNOWN = 0;
        MAP = 1; // Lift T -> U, pure
        FILTER = 2; // Lift T -> bool, pure
        FOLD = 3; // Lift [T] -> U, pure
        TAKE = 4; // Nullary, pure
        TAKEWHILE = 5; // Lift T -> bool, pure
        TAKEFIRST = 6; // Nullary, returns single, pure
        TAKELAST = 7; // pure
        DROP = 8; // pure
        DROPWHILE = 9; // pure
        FOREACH = 10; // Lift T -> U, effectful
        CONCAT = 11; // pure
        FLATMAP = 12; // MAP andthen CONCAT
        SETALL = 13; // effectful
        DELETEALL = 14; // effectful
    }
    FunctionType ty = 1;
    Function fn = 2;
}

// FunctionSplit :: (a -> b) -> (a -> c) -> .. -> merge ((b, c, ..) -> d) -> (a -> d)
// Use FunctionSplit to simulate Join operations
message FunctionSplit {
    repeated Function fn = 1;
    Function merge = 2;
}


message Function {
    oneof fn {
        FunctionNumeric numeric = 1;
        FunctionEffectful effectful = 2;
        FunctionSelectField selectField = 3;
        FunctionSequence sequence = 4;
        FunctionSplit split = 5;
    } 
}

message BytesState {
    bytes key = 1;
    bytes value = 2;
}

message QueryEnumerableRequest {
    repeated FunctionEnumerable ops = 1;
}

message QueryEnumerableResponse {
    repeated BytesState bytesEnumarable = 1;    
}

message QuerySingleRequest {
    repeated Function ops = 1;
}

message QuerySingleResponse {
    BytesState bytesSingle = 1;
}

service QueryEnumerableService {
    rpc QueryEnumerable(QueryEnumerableRequest) returns (QueryEnumerableResponse);
}

service QuerySingleService {
    rpc QuerySingle(QuerySingleRequest) returns (QuerySingleResponse);
}
